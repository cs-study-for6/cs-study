# 메모리란?
메모리란 프로그램과 프로그램 수행에 필요한 데이터 및 코드를 저장하는 장치이다.
메모리는 크게 내부 기억장치인 주기억장치와 외부 기억장치인 보조 기억장치로 분류되는데
DRAM, CPU 안에 있는 레지스터(register)와 캐쉬(cache memory) 등이 전자에 해당되고
SSD, HDD 등이 후자에 해당된다.

### 1. RAM (Random Access Memory)  
RAM은 프로그램이 실행되는 동안 필요한 데이터 및 명령을 저장하는 데 사용되며 주소를 통해 직접 데이터에 액세스할 수 있고 휘발성 메모리이며 프로그램 실행, 데이터 저장 등에 사용된다.

### 2. ROM (Read-Only Memory)  
ROM은 컴퓨터의 부팅 프로세스 및 시스템 설정과 같은 핵심 프로그램 및 데이터를 저장한다. 읽기 전용 메모리이기 때문에 내용을 수정할 수 없고 비휘발성이며 부트 로더, 펌웨어, 시스템 BIOS 등에 사용된다.

### 3. 캐시 메모리 (Cache Memory)  
캐시 메모리는 CPU가 자주 액세스하는 데이터를 임시로 저장하여 전체 시스템 성능을 향상시켜 빠른 액세스 속도를 가지며 일반적으로 L1, L2, L3 캐시로 구분된다. 주로 CPU 성능 향상 및 전력 소모 감소를 위해 사용된다.

### 4. 보조 저장 장치 (Secondary Storage)  
보조 저장 장치는 데이터를 장기적으로 저장하고 영구적으로 유지한다. 예시로는 하드 디스크 드라이브 (HDD), 솔리드 스테이트 드라이브 (SSD)가 존재한다. 비휘발성이며 큰 용량을 제공하여 데이터 저장, 파일 시스템 운영 등에 사용된다.

### 5. 가상 메모리 (Virtual Memory)  
가상 메모리는 물리적 메모리의 부족을 보완하여 큰 프로그램 및 데이터를 실행할 수 있도록 한다.
물리적 메모리를 확장하는 역할을 하며 디스크 공간을 사용하여 메모리 부족 문제 해결, 여러 프로그램 동시 실행 등에 사용된다.<br/><br/><br/>


# 가상메모리 (Virtual Memory)  

## 등장 배경
1. 초창기 컴퓨터에서는 사용 가능한 RAM의 용량이, 가장 큰 실행 애플리케이션의 주소 공간보다 커야만 실행이 가능했다. <br/><br/>
2. 이후 컴퓨터에서는 프로그래머가 애플리케이션의 일부분만 기억장치에 올려 실행하도록 지정할 수 있게 하는 오버레이 기법을 사용하여 메모리 부족 문제를 해결하고자 했었다. <br/><br/>
3. 가상 메모리 기법은 애플리케이션을 실행하는 데 얼마나 많은 메모리가 필요한지에 집중하지 않고, 대신 애플리케이션을 실행하는 데 최소한 얼마만큼의 메모리가 필요한가에 집중하여 문제를 해결하고자 하였다.  <br/><br/>
4. 메모리 접근은 순차적이고 지역화되어 있기 때문에 적용될 수 있었고 이렇게 애플리케이션의 일부분만 메모리(기억장치)에 올려지며 메모리에 올라가지 않는 나머지는 보조 기억장치, 즉 디스크에 위치시키게 되었다. <br/><br/>

## 아이디어  
 
1. 어떤 프로세스가 실행될 때 메모리에 해당 프로세스 전체가 올라가지 않더라도 실행이 가능하다.<br/><br/>
2. 따라서 애플리케이션이 실행될 때, 실행에 필요한 일부분만 메모리에 올라가게 하고 나머지는 디스크에 남겨두어 디스크가 RAM의 보조 기억장치(backing store)처럼 작동하게 할 수 있다.<br/><br/>
3. 결국 빠르고 작은 기억장치(RAM)을 크고 느린 기억장치(디스크)와 병합하여, 하나의 크고 빠른 기억장치(가상 메모리)처럼 동작하게 하는 것임.<br/><br/>
4. 대신 이런 병합된 모습의 가상 메모리를 구현하기 위해서 컴퓨터는 특수 메모리 관리 하드웨어를 갖추어야 한다. ⇒  MMU(Memory Management Unit)!

## MMU (Memory Management Unit)

1. MMU는 가상주소를 물리주소로 변환하고, 메모리를 보호하는 기능을 수행한다.<br/><br/>
2. MMU를 사용하게 되면, CPU가 각 메모리에 접근하기 이전에 메모리 주소 번역 작업이 수행됨.<br/><br/>
3. 그러나 메모리를 일일이 가상 주소에서 물리적 주소로 번역하게 되면 작업 부하가 너무 높아지므로, MMU는 RAM을 여러 부분(페이지, pages)로 나누어 각 페이지를 하나의 독립된 항목으로 처리함.<br/><br/>

![alt text](images/image-1.png)

### MMU의 메모리 보호  
프로세스는 독립적인 메모리 공간을 가져야하므로 MMU는 한 프로세스에게 합법적인 주소 영역을 설정하고, 잘못된 접근이 오면 trap을 발생시키며 보호한다. base와 limit 레지스터를 활용하여 이를 구현한다.  
- base 레지스터 : 메모리상의 프로세스 시작주소를 물리 주소로 저장
- limit 레지스터 : 프로세스의 사이즈를 저장

프로세스의 접근 가능한 합법적인 메모리 영역(x)은 base <= x < base+limit 인 부분이다. 이 영역 밖에서 접근을 요구하면 trap을 발생시킨다.

![alt text](images/image.png)

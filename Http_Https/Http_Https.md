## HTTP & HTTPS

- **Http(HyperText Transfer Protocol)**
    - 인터넷 상에서 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약
    예를 들어, 인터넷 주소를 지정할 때, `http://www.naver.com`와 같이 시작하는 것은 `www.naver.com`이라는 인터넷 주소가 가진 데이터 정보 등의 교환을 HTTP의 통신 규약대로 처리하라는 것을 의미한다.
    - HTTP는 암호화가 되지 않은 평문 데이터를 전송하는 프로토콜이였기 때문에, HTTP로 
    비밀번호, 주민등록번호 등 개인 정보를 주고받으면 제3자가 정보를 열람할 수 있었다.
    이러한 보안 문제를 해결하기 위해 등장한 프로토콜이 **‘HTTPS’(HyperText Transfer Protocol Secure)**이다.
    - **HTTP의 보안 취약점**
        1. `도청이 가능하다.`
            1. 평문으로 통신하기 때문에 도청이 가능하다.
                1. 이를 해결하기 위해 통신 자체를 암호화(HTTPS)하거나 데이터를 암호화 
                하는 방법 등이 있다.
            2. 데이터를 암호화 하는 경우 수신측에서는 복호화 과정이 필요하다.
        2. `위장이 가능하다.`
            1. 통신 상대를 확인하지 않기 때문에 위장한 상대와 통신할 수도 있다.
            2. HTTPS는 CA인증서를 통해 인증된 상대와 통신이 가능하다.
        3. `변조가 가능하다.`
            1. 완전성을 보장하지 않기 때문에 변조가 가능하다.
            2. HTTPS는 메세지 인증 코드(MAC), 전자 서명 등을 통해 변조를 방지한다.
    - 장점
        - 통신 간의 연결 상태 처리나 상태 정보를 관리할 필요가 없어 서버 디자인이 간단하다.
        - 각각의 HTTP 요청에 독립적으로 응답만 보내주면 된다.
        - HTTPS에 비해 속도가 빠르다.
    - 단점
        - 이전 통신의 정보를 모르기 때문에 매번 인증을 해줘야 한다.
        - 보안이 취약하다.

- **HTTPS(HyperText Transfer Protocol Secure)**
    - 인터넷 상에서 정보를 암호화하는 SSL 프로토콜을 사용해 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약
    
    - HTTPS는 대칭키 암호화 방식과 비대칭키 암호화 방식을 모두 사용하고 있다.
        - `대칭키 암호화`
            - 클라이언트와 서버가 동일한 키를 사용해 암호화/복호화를 진행
            - 키가 노출되면 매우 위험하지만 연산 속도가 빠름
        - `비대칭키 암호화`
            - 공개키/개인키 암호화 방식을 이용해 데이터를 암호화
            - 공개키와 개인키는 서로를 위한 1쌍의 키
            - 1개의 쌍으로 구성된 공개키와 개인키를 암호화/복호화하는데 사용함
            - 키가 노출되어도 비교적 안전하지만 연산 속도가 느림
    
    - **HTTPS 통신 흐름**
        1. 애플리케이션 서버(A)를 만드는 기업은 HTTPS를 적용하기 위해 공개키와 개인키를 만든다.
        2. 신뢰할 수 있는 CA 기업을 선택하고, 그 기업에게 내 공개키 관리를 부탁하며 계약을 한다.
            
            <aside>
            💡 **CA 기업** : Certificate Authority, 공개키를 저장해주는 신뢰성이 검증된 
            민간기업
            
            </aside>
            
        3. 계약 완료된 CA 기업은 해당 기업의 이름, A서버 공개키, 공개키 암호화 방법을 담은 인증서를 만들고, 해당 인증서를 CA 기업의 개인키로 암호화해서 A서버에게 제공한다.
        4. A서버는 암호화된 인증서를 갖게 되었다. 이제 A서버는 A서버의 공개키로 암호화된 HTTPS 요청이 아닌 다른 요청이 오면, 이 암호화된 인증서를 클라이언트에게 건내준다.
        5. 클라이언트가 `main.html` 파일을 달라고  A서버에 요청했다고 가정하자. HTTPS 요청이 아니기 때문에 CA기업이 A서버의 정보를 CA 기업의 개인키로 암호화한 인증서를 받게 된다.
        6. 브라우저는 해독한 뒤 A서버의 공개키를 얻는다.
        7. 클라이언트가 A서버와 HandShaking 과정에서 주고받은 난수를 조합하여 pre-master-secret-key를 생성한 뒤, A서버의 공개키로 해당 대칭키를 암호화하여 서버로 보낸다.
        8. A서버는 암호화된 대칭키를 자신의 개인키로 복호화하여 클라이언트와 동일한 대칭키를 획득한다.
        9. 클라이언트, 서버는 각각 pre-master-secret-key를 master-secret-key로 만든다.
        10. master-secret-key를 통해 session-key를 생성하고 이를 이용하여 대칭키 방식으로 통신한다.
        11. 각 통신이 종료될 때마다 session-key를 파기한다.
            
            ![Untitled 3.png](./CS%2098b04128a3e848d49b2cb8a8c2ca38d0/Untitled_3.png)
            
            ![Untitled 4.png](./CS%2098b04128a3e848d49b2cb8a8c2ca38d0/Untitled_4.png)
            
            ![Untitled 5.png](./CS%2098b04128a3e848d49b2cb8a8c2ca38d0/Untitled_5.png)
            
    - 장점
        - 네트워크 상에서 열람, 수정이 불가능하므로 비교적 안전하다.
        - 키워드 검색 시 상위 노출되는 기준 중 하나가 보안 요소이다.
    - 단점
        - 설치 및 인증서를 유지하는 데 추가 비용이 발생한다.
        - 암호화하는 과정이 웹 서버에 부하를 줄 수 있다.
        - HTTP에 비해 속도가 느리다.
        - 인터넷의 연결이 끊긴 경우 재인증 시간이 소요된다.
            - HTTP는 비연결형으로 웹페이지를 보는 중에 인터넷의 연결이 끊겼다가 다시 연결되어도 페이지를 계속 볼 수 있다.
            - HTTP는 소켓(데이터를 주고 받는 경로) 자체에서 인증을 하기 때문에 인터넷의 연결이 끊기면 소켓도 끊어져서 다시 HTTPS 재인증이 필요하다.
    

![그림 출처 : [https://aws.amazon.com/ko/compare/the-difference-between-https-and-http/](https://aws.amazon.com/ko/compare/the-difference-between-https-and-http/)](./CS%2098b04128a3e848d49b2cb8a8c2ca38d0/Untitled%203.png)

그림 출처 : [https://aws.amazon.com/ko/compare/the-difference-between-https-and-http/](https://aws.amazon.com/ko/compare/the-difference-between-https-and-http/)

- **공개키/개인키**
    - `공개키 암호화` : 공개키로 암호화를 하면 개인키로만 복호화할 수 있다. 개인키는 나만 가지고 있으므로 나만 볼 수 있다.
    - `개인키 암호화` : 개인키로 암호화하면 공개키로만 복호화할 수 있다. 공개키는 모두에게 공개되어 있으므로 내가 인증한 정보임을 알려 신뢰성을 보장할 수 있다.
    
    ![Untitled](./CS%2098b04128a3e848d49b2cb8a8c2ca38d0/Untitled%204.png)
    

참고

- [https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Network/HTTP %26 HTTPS.md](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Network/HTTP%20%26%20HTTPS.md)
- [https://mangkyu.tistory.com/98](https://mangkyu.tistory.com/98)

- HTTP에서의 인증방식
    - Basic Authentication(기본 인증)
        - 사용자 이름과 비밀번호를 인코딩한 문자열을 HTTP 요청 헤더의 “Authorization” 필드에 포함하여 전송
        - 매우 안전하지 않아서 SSL/TLS와 함께 사용
        ex) Authorization: Basic base64encoded(username:password)
    - Bearer Token Authentication(토큰 기반 인증)
        - 클라이언트가 발급받은 토큰을 HTTP 요청 헤더의 “Authorization”필드에 “Bearer”접두어와 함께 포함하여 전송. Authorization 헤더에 토큰을 포함하여 전송
        - JWT을 사용하여 인증
        
        <aside>
        💡 JWT(JSON Web Token)
        클레임이라고 불리는 정보를 JSON 형태로 안전하게 전송하기 위핸 토큰 기반의 표준
        
        </aside>
        
        - 간단한 방식, 상태를 유지하지 않음, 확장성이 높음
        - 토큰의 노출 위험, 토큰의 관리가 힘듦
        ex) Authorization: Bearer token_value
        - 일반적으로 인증과 정보 교환에 사용, 서명이 되어 있어 신뢰성 확보가 가능
    - OAuth(Open Authorization)
        - 토큰기반의 인증 방식, 사용자가 직접 자격을 증명하는 것이 아니라 미리 인증을 받아서 토큰을 발급받고 이 토큰을 이용하여 API를 요청하는 방식
        - 일반적으로 OAuth 2.0을 사용하고 있음
        - 주로 서셜 미디어 플랫폼(Facebook, GOogle, Twitter 등)에서 사용
    - API Key Authentication(API 키 인증)
        - key를 발급받고 키를 포함해서 서버에 전송
        - 주로 공개 API에 접근할 때 사용된다.
    - Session-based Authentication(세션 기반 인증)
        - 사용자가 로그인하면 서버는 세션 ID를 생성하고 클라이언트에게 전달한다.
        클라이언트는 이 세션 ID를 유지하며 요청 시 서버에 제공하여 인증
        - 주로 웹 애플리케이션에 사용되며, 상태를 유지하는 방식
- 소켓
    - 네트워크에서의 소켓은 프로그램을 뜻한다. 멀리 떨어져있는 host(컴퓨터)간에 데이터를 주고 받을 수 있도록 프로그램으로 구현한 것을 소켓이라고 한다.
    - 모든 네트워크 프로그램은 소켓을 통하여 통신망으로 데이터를 송수신한다.
    - 우리는 소켓을 이용하여 TCP나 UDP에 접근할 수 있다.
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/3cdcda21-8a3d-4fd5-890b-23e67f8f4713/3bd416fd-08ba-455d-9326-570f58c2ed26/Untitled.png)
    
- 소켓의 통신 과정
    - 소켓은 서버 소켓(Server Socket)과 클라이언트 소켓(Client Socket)으로 구성되어 있다.
    - 소켓 통신은 아래 과정을 통해 이루어진다
        - socket()으로 통신을 위한 엔드포인트를 작성하고 해당 종료점을 나타내는 소켓 설명자를 리턴한다. 소켓 설명자는 정수로 이루어져 있다.
        - 소켓 설명자가 있는 어플리케이션은 고유한 이름을 소켓에 바인드할 수 있다. 서버 소켓은 네트워크에서 엑세스 가능한 이름을 바인드해야 한다.
        - 서버 소켓에서 listen()으로 클라이언트 연결 요청을 승인하려는 의사를 표시한다.
        - 클라이언트 어플리케이션이 스트림 소켓에 대해 connect() API를 사용하여 서버에 대한 연결을 설정한다.
        - 서버 어플리케이션이 accept() API를 사용하여 클라이언트 연결 요청을 승인한다.
        - 서버와 클라이언트 간 연결이 이루어지면 모든 데이터 전송을 할 수 있다.
        - 서버 또는 클라이언트 조작을 중단하려는 경우 close()를 실행하여 소켓이 획득한 시스템 자원을 해제한다.
        
- 소켓의 역할
    - 일반적으로, 서버는 특정 컴퓨터 위에서 돌아가고 특정 포트넘버에 할당된 소켓을 갖는다. 이 서버는 클라이언트가 커넥션 요청을 만들기 위한 소켓을 리스닝하며 기다린다.
    클라이언트 쪽에서 커넥션이 성립된 경우 소켓이 성공적으로 생성되며 클라이언트는 소켓을 서버와 상호작용하기 위해 사용할 수 있다.
    소켓이란 네트워크 위에서 돌아가는 두 프로그램 간의 양방향 통신링크의 엔드포인트이다. 소켓은 포트 넘버를 할당받아 TCP레이어가 데이터의 목적지인 애플리케이션을 식별하도록 한다. 엔드포인트는 IP주소와 포트넘버의 조합이다
    - HTTP는 TCP 위에서 동작한다. 때문에 HTTP연결의 시작과 끝에는 TCP연결과 해제가 이루어져야 한다.

- HTTP에서 이전 통신의 정보를 모르기 때문에 매번 인증
    - HTTP는 TCP 위에서 동작한다. 때문에 HTTP연결의 시작과 끝에는 TCP연결과 해제가 이루어져야 한다.
    - 연결이 끊어진 후 새로 동작을 하기 위해서는 사용자가 이전 사용자와 같은 사용자임을 매번 인증
    - 한 번의 연결에 1요청, 1응답만 처리 가능하므로 매번 새로운 연결로 성능 저하 및 서버 부하 비용 증가
    - HTTP/1.1버전부터는 `Presistent connection`이라 해서 지정한 timeout 동안 연속적인 요청 사이에 커넥션을 닫지 않는다.

- HTTP가 HTTP보다 속도가 빠른 이유
    - HTTPS는 암호화/복호화 과정이 필요하기 때문에 HTTP보다 속도가 느리다.

- ‘키워드 검색 시 상위 노출되는 기준 중 하나가 보안 요소이다’라는 부분
    - 네이버 다음은 물론이고 구글도 검색 엔진 최적화 관련 내용을 HTTPS 웹사이트에 대하여 적용하고 있다.
    즉, 키워드 검색 사 상위 노출되는 기준 중 하나가 보안요소인셈.
    
    <aside>
    💡 **검색 엔진 최적화(SEO:Search Engine Optimizaion)**
    검색엔진이 이해하기 쉽도록 홈페이지의 구조와 페이지를 개발해 검색 결과 상위에 노출될 수 있도록 하는 작업을  말한다.
    동일 사이트 기준 HTTPS를 사용하면 HTTP를 사용해 서비스 하는 것보다 구글 검색엔진에서 약 1%에 해당하는 랭킹 가산점을 부여한다.
    
    </aside>
    
    - 2014년 구글에서는 HTTP를 HTTPS로 바꾸라고 권고.
    - HTTPS로의 전환을 장려하기 위해 구글은 HTTPS를 사용하는 웹사이트에 대해서 검색 순위 결과에 약간의 가산점을 주겠다고 발표
